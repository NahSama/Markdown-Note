# Background

Program should be loaded from secondary memory to primary one. CPU only generate logical address, which then be mapped to physical one by OS.

# Address binding

1. Logical Address: Generated by CPU. Used as reference to the Physical Address. A special hardware (MMU unit, managed by OS) is used to do this conversion job.
2. Physical Address: Real address at a memory unit (RAM)

Happens in compile time/ load time/ or run time

# Linking

Action of link object code (from source code) with other library referenced in the source code.

`Object files + External Libs = Executable file`

1. Static Linking
    - Copy directly code of external libs into Executable file
    - Disadvantages:
        - increase loading time
        - if bug in external libs, then recompiling is needed
2. Dynamic linking
    - Instead, just store pointer to the code of external libs. Then during run time, loader will see at the pointing address to get the code.

# Loading

Load a program from secondary to main memory

1. Static loading: Load all the code at 1 time
2. Dynamic loading: Only load when needed

# Swapping & Overlays

-   Swapping is the action of swapping in & out process from/ to the main memory. So that, only running process is kept to make room for others.
-   When a program is too big & not fit in the main mem, it can be divided into _independent smaller ones_ (called overlays). And only the needed one is loaded into RAM (typically used in contiguous mem alloc)

# Memory allocation

**1. Contiguous allocation (like an array)**

-   Fixed/ static partition
    -   Internal fragmentation
    -   Ez to implement
-   Dynamic/ variable length partition
    -   external fragmentation when proc leaves

Yet, can be solved by:

-   Compaction: periodically move all used to one end. But this takes time & running process is suspended to do this
    ![](images/compaction.png)

-   Non-contiguous allocation (see below)

**2. Non-contiguous allocation (like a linked-list)**

Logical Address Space of a process >= its Physical Address Space, which OS allocated to it.

-   Paging

    -   Physical Address is divided into FRAMES (by OS)
    -   Logical Address is divided into PAGES **(of the same size)** (by OS)
    -   Then a **map table** is created (inside RAM) for each proc to map between frames & pages. A dedicated register can be used to store location of map table in RAM
    -   Map table look-up time can be optimized using **TLB**, special cache hardware in MMU (only have 1, will be flushed when context switching).

        -   Each time looking up for frames in the table, it requires 2 memory access:
            -   One to know where is page table in main memory
            -   One to know where is the frame
        -   With the help of TLB, we only do step number 2

    -   Shared paging: Page can be shared between process
    -   [ Structure of page table ](https://www.youtube.com/watch?v=Sa3Z-aFINuE) (when page table is too big to be kept in the main mem, we need to do sth)

        -   Multi level page table. [How much mem it save?](https://stackoverflow.com/questions/29467510/how-does-multi-level-page-table-save-memory-space)
        -   Inverted
        -   Hashed

    -   Advantage:
        -   Eliminates almost the internal frag
        -   Faster than segmentation
    -   Disadvantage:
        -   No user view support. So some related code (in user view) can be lying in different pages

-   Segmentation
    -   Physical Address is divided into segments (variable length size, specified by users). Normally, users decide segmentation strategy
    -   Advantage:
        -   No internal frag
        -   smaller mapping table size
        -   user view support
        -
    -   Disadvantage:
        -   external frag
        -   complex memory allocation algo
        -   Large segment can be hard to be allocated
        -   slower than paging

# Virtual memory

-   System should support run time address binding

-   Action of using secondary memory to support RAM, so that more program (with total logical address much larger than physical one) can be run concurrently. Running program will be swapped into RAM, while idle one is swapped out to hard disk.
-   Implementation:
    -   Demand paging
    -   Demand segmentation
